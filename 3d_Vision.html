<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>3D – 5LSH0 computer vision and ai</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-0b37c64f34216b628666a8dac638b53b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">5LSH0 computer vision and ai</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/robertvs333/computer-vision-and-ai"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#projective-geometry" id="toc-projective-geometry" class="nav-link active" data-scroll-target="#projective-geometry">Projective geometry</a></li>
  <li><a href="#how-do-we-calculate-this-f" id="toc-how-do-we-calculate-this-f" class="nav-link" data-scroll-target="#how-do-we-calculate-this-f">How do we calculate this F?</a></li>
  <li><a href="#taking-into-account-extrensic-camera-parameters" id="toc-taking-into-account-extrensic-camera-parameters" class="nav-link" data-scroll-target="#taking-into-account-extrensic-camera-parameters">Taking into account extrensic camera parameters</a></li>
  <li><a href="#camera-calibration" id="toc-camera-calibration" class="nav-link" data-scroll-target="#camera-calibration">Camera calibration</a></li>
  <li><a href="#d-sensors" id="toc-d-sensors" class="nav-link" data-scroll-target="#d-sensors">3D sensors</a>
  <ul class="collapse">
  <li><a href="#how-to-store-the-3d-data" id="toc-how-to-store-the-3d-data" class="nav-link" data-scroll-target="#how-to-store-the-3d-data">How to store the 3D data</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">3D</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>How does a film/sensor actually capture a photo? The pinhole which is basically just a small aperature model make sure that pictures do not get blurry.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Screenshot 2025-12-09 at 19.26.35.png" class="img-fluid figure-img"></p>
<figcaption>“Screenshot from lectur about pinhole model”</figcaption>
</figure>
</div>
<p>A major downside is that it doesn’t gather much information because not much light is going through it. That is why modern camera’s are using lenses</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Screenshot 2025-12-09 at 19.32.36.png" class="img-fluid figure-img"></p>
<figcaption>“Screenshot of slide regarding lens camera”</figcaption>
</figure>
</div>
<section id="projective-geometry" class="level2">
<h2 class="anchored" data-anchor-id="projective-geometry">Projective geometry</h2>
<p>Projective geometry is used to develop an equation to map a 3d point to a 2d pixel.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Screenshot 2025-12-09 at 19.41.29.png" class="img-fluid figure-img"></p>
<figcaption>“Screenshot of slide”</figcaption>
</figure>
</div>
<p>However this will not be done in cartesian coordinate system but in homogenous coordinates. Which is just basically: <span class="math display">\[ (x,y) \implies \begin{bmatrix} x \\ y \\ 1 \end{bmatrix}  \]</span> The homogenous coordinate does not care about the distance, it is also scale-invariant. This homegenous coordinate system makes it possible to do 3d matrix multiplication</p>
<p>Converting to homogenous coordinate to cartesian is to always just add 1 as another dimension. It can be converted back by: <span class="math display">\[ \begin{bmatrix} x \\ y \\ w \end{bmatrix} =&gt; (x/w,y/w)\]</span></p>
<p>as previously said it is invariant to scaling this is proved in the following: <span class="math display">\[K\begin{bmatrix}x\\y\\w\\\end{bmatrix} = \begin{bmatrix}kx\\ky\\kyw\end{bmatrix}=&gt;\begin{bmatrix}\frac{kx}{kw}\\\frac{ky}{kw}\end{bmatrix}=&gt;\begin{bmatrix}\frac{x}{w}\\\frac{y}{w}\end{bmatrix}\]</span></p>
<p>So how do we map a 3d point to 2d map?</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Screenshot 2025-12-09 at 20.03.34.png" class="img-fluid figure-img"></p>
<figcaption>“Image for clarifying which point is which”</figcaption>
</figure>
</div>
<p>First we need to get rid of z which is possible by using the following principle:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Screenshot 2025-12-09 at 20.05.32.png" class="img-fluid figure-img"></p>
<figcaption>“getting rid of z”</figcaption>
</figure>
</div>
<p><span class="math display">\[
\frac{x_s}{d} = \frac{x_v}{z_v} \quad \text{and} \quad \frac{y_s}{d} = \frac{y_v}{z_v}
\]</span></p>
<p>These can be rearranged such that:</p>
<p><span class="math display">\[
z_v \frac{x_s}{1} = d \frac{x_v}{1} \quad \text{and} \quad z_v \frac{y_s}{1} = d \frac{y_v}{1}
\]</span></p>
<p>this can also be converted into a matrix:</p>
<p><span class="math display">\[
z_v \begin{pmatrix}
x_s \\\\
y_s \\\\
1
\end{pmatrix}
=
\begin{pmatrix}
d &amp; 0 &amp; 0 &amp; 0 \\\\
0 &amp; d &amp; 0 &amp; 0 \\\\
0 &amp; 0 &amp; 1 &amp; 0
\end{pmatrix}
\begin{pmatrix}
x_v \\\\
y_v \\\\
z_v \\\\
1
\end{pmatrix}
\]</span></p>
<p>d is our focal length also known as f which results in:</p>
<p><span class="math display">\[
z_v \begin{pmatrix}
x_s \\\\
y_s \\\\
1
\end{pmatrix}
=
\begin{pmatrix}
f &amp; 0 &amp; 0 &amp; 0 \\\\
0 &amp; f &amp; 0 &amp; 0 \\\\
0 &amp; 0 &amp; 1 &amp; 0
\end{pmatrix}
\begin{pmatrix}
x_v \\\\
y_v \\\\
z_v \\\\
1
\end{pmatrix}
\]</span></p>
<p>However f is given in mm and we want to have the results in pixels.</p>
<p>A new function F is introduced</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Screenshot 2025-12-09 at 20.16.41.png" class="img-fluid figure-img"></p>
<figcaption>“Show the units of each metric”</figcaption>
</figure>
</div>
<p>what must be included in F: 1. Varying focal length 2. Skew (not all pixels are rectangular) 3. Radial distortions 4. Principal Point offset 5. Pixel size</p>
<p>These are also called intrinsic carama parameters because those are varying per camera unit. Even between the same two camera’s</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Screenshot 2025-12-11 at 10.05.58.png" class="img-fluid figure-img"></p>
<figcaption>“Explanation of principal point”</figcaption>
</figure>
</div>
</section>
<section id="how-do-we-calculate-this-f" class="level2">
<h2 class="anchored" data-anchor-id="how-do-we-calculate-this-f">How do we calculate this F?</h2>
<ol type="1">
<li>Principal point offset</li>
</ol>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Screenshot 2025-12-11 at 11.20.22.png" class="img-fluid figure-img"></p>
<figcaption>“Replacement of u_0 and v_O”</figcaption>
</figure>
</div>
<ol start="2" type="1">
<li>Non square pixels</li>
</ol>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Screenshot 2025-12-11 at 11.21.59.png" class="img-fluid figure-img"></p>
<figcaption>“Remove assumption: non-square pixels”</figcaption>
</figure>
</div>
<ol start="2" type="1">
<li>Skew</li>
</ol>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Screenshot 2025-12-11 at 11.23.38.png" class="img-fluid figure-img"></p>
<figcaption>“Removing skew”</figcaption>
</figure>
</div>
<p>W is not important, it is often also called f or z. The values for u and v should be rounded up to make it integers</p>
</section>
<section id="taking-into-account-extrensic-camera-parameters" class="level2">
<h2 class="anchored" data-anchor-id="taking-into-account-extrensic-camera-parameters">Taking into account extrensic camera parameters</h2>
<p>The extrensic camera matrix is the mathematical link between the real world coordinate system and the camera coordinate system. It therefore specificies two things: 1. Camera position 2. Camera orientation</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Screenshot 2025-12-11 at 11.35.16.png" class="img-fluid figure-img"></p>
<figcaption>“Screenshot of slide”</figcaption>
</figure>
</div>
<p>For movement the updated matrix becomes:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Screenshot 2025-12-11 at 11.36.59.png" class="img-fluid figure-img"></p>
<figcaption>“The camera is only being moved”</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Screenshot 2025-12-11 at 11.40.54.png" class="img-fluid figure-img"></p>
<figcaption>“Counter-clockwise rotation around the coordinate axes”</figcaption>
</figure>
</div>
<p>These three need to be multiplied because all of them are acting on the x,y and z coordinate.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Screenshot 2025-12-11 at 11.43.35.png" class="img-fluid figure-img"></p>
<figcaption>“Result of multiplication”</figcaption>
</figure>
</div>
<p>The picture will not be asked on the exam.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Screenshot 2025-12-11 at 11.46.07.png" class="img-fluid figure-img"></p>
<figcaption>“Screenshot of slide”</figcaption>
</figure>
</div>
<p>The end result will be:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Screenshot 2025-12-11 at 11.47.17.png" class="img-fluid figure-img"></p>
<figcaption>“End result for extrensic camera parameters”</figcaption>
</figure>
</div>
<p>The r11 r12… are the ones provided in the end result which doesn’t have to be studied for the exam. The left matrix is determining the qualtiy of the camera (intrinsic) while the right part is the extrensic part.</p>
</section>
<section id="camera-calibration" class="level2">
<h2 class="anchored" data-anchor-id="camera-calibration">Camera calibration</h2>
<p>During calibration we are determining the intrincis and extrensic parameters. This is done by combining the intrinsic and extrensic into one matrix which is the projecteion matrix (3x4) which has 11 degrees of freedom (scaling invariance). This is the case becuase the right bottom value is always equal to 1. So we need to find 11 parameters</p>
<p>How to do this (one of many examples): 1. place the camera in a known position assume that this is the origin 2. place a chess board in front of the camera with known distances between blocks 3. take at least 6 (non-planar) points from this image and their corresponding real world coordinate, more is beneficial of course. 4. Convert the following matrix equation to linear set of equations: <img src="images/Screenshot 2025-12-11 at 12.03.33.png" class="img-fluid" alt="“screenshot of slide”"> 5. Rewrite this to: <img src="images/Screenshot 2025-12-11 at 12.04.43.png" class="img-fluid" alt="“Screenshot of slide”"></p>
<p>Real world case more than 6 points is used and the equation systems gets over-constrained and therefore it is solved using aLeast Squares Minimization. Not always results are found due to for example radial distortion and such things.</p>
</section>
<section id="d-sensors" class="level1">
<h1>3D sensors</h1>
<p>There are 2 types of sensors to determine the depth. Passive (indirect) which do not emit any acoustic signals such as stereo camera or a moving camera. There are also active (direct) sensors such as ToF, LiDARs, structured light sensors, light-field sensors which uses different focal lengths and such.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Screenshot 2025-12-11 at 12.31.40.png" class="img-fluid figure-img"></p>
<figcaption>“The principles of structured light sensor”</figcaption>
</figure>
</div>
<p>This sensor is highly sensitive to sunlight due to IR coming from the sun. Multiple structured light sensors and time of flight sensors will give issues due to interference on each other.</p>
<p>The eyes use disparity. The following picture shows this.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Screenshot 2025-12-11 at 12.39.55.png" class="img-fluid figure-img"></p>
<figcaption>“Disparity in eye”</figcaption>
</figure>
</div>
<p>In cameras the depth is also calculated from disparity. This is done by using feature matching with for example SIFT features.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Screenshot 2025-12-11 at 12.42.42.png" class="img-fluid figure-img"></p>
<figcaption>“Disparity in camera”</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Screenshot 2025-12-11 at 12.44.16.png" class="img-fluid figure-img"></p>
<figcaption>“Screenshot of slide”</figcaption>
</figure>
</div>
<p>From disparity we can go quite easily to depth namely:</p>
<div class="callout callout-style-default callout-note callout-titled" title="Disparity to depth">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Disparity to depth
</div>
</div>
<div class="callout-body-container callout-body">
<p>The depth can be calculated using: <span class="math display">\[
z=\frac{b*f}{p*d},
\]</span> <strong>Where:</strong> * <span class="math inline">\(z\)</span> is depth * <span class="math inline">\(b\)</span> is baseline * <span class="math inline">\(f\)</span> is focal length * <span class="math inline">\(p\)</span> is pixel width * <span class="math inline">\(d\)</span> is disparity</p>
</div>
</div>
<p>Non prominent areas in a picture will not contain any features and therefore no features can be matched and no disparity can be calculated. Also if the matching is incorrect the depth will also be completely different. This is a major drawback. Therefore stereo cameras are not reliable. However a stereo camera can have unlimited range although this is still based on the baseline. So if you can use active sensor, however there a various reasons why you must use passive setup, in which using ir can be harmfull for the environment or to the target.</p>
<p>LiDaR uses different scanning mechanisms to make sure that it records in 2d instead of in only one direction.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Screenshot 2025-12-11 at 14.46.32.png" class="img-fluid figure-img"></p>
<figcaption>“Scanning mechanism LiDAR”</figcaption>
</figure>
</div>
<p>4D imaging radar actually gives 4 dimensions: 1. Distance 2. Direction 3. Height 4. Object speed (based on the Doppler effect) 5. (Actually also material)</p>
<p>This radar is als GDPR approved. all other sensors cannot see through fog however 4d imaging radar can. This radar sends RF signal.</p>
<section id="how-to-store-the-3d-data" class="level2">
<h2 class="anchored" data-anchor-id="how-to-store-the-3d-data">How to store the 3D data</h2>
<ol type="1">
<li>Voxel <img src="images/Screenshot 2025-12-11 at 15.04.26.png" class="img-fluid" alt="“Voxel grid”"></li>
<li>Octree-based Model <img src="images/Screenshot 2025-12-11 at 15.07.36.png" class="img-fluid" alt="“Octree-based model”"></li>
<li>Point cloud <img src="images/Screenshot 2025-12-11 at 15.10.12.png" class="img-fluid" alt="“Point cloud”"></li>
<li>Mesh <img src="images/Screenshot 2025-12-11 at 15.11.48.png" class="img-fluid" alt="“Mesh”"></li>
<li>Depth image (RGB-D) Just images each with a depth-value</li>
<li>NeRF <img src="images/Screenshot 2025-12-11 at 15.13.34.png" class="img-fluid" alt="“NeRF”"></li>
</ol>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/robertvs333\.github\.io\/computer-vision-and-ai\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>